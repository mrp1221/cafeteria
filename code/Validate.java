package code;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * Validates a simulation
 * 
 * @author Ian Parks
 */
public class Validate {
	
	private static int count = 0;
	
	private static class InvalidSimulationException extends Exception {

		private static final long serialVersionUID = 1L;

		public InvalidSimulationException() {
		}
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
		String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : " + message);
			System.err.println("\tIssue found with event #" + count);
			throw new Validate.InvalidSimulationException();
		}
	}

	/**
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @author Ian Parks
	 *
	 * @param events - a list of events generated by the simulation
	 *        in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */

	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {
			// Check for simulation starting and ending...
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
				"Simulation didn't start with initiation event");
			check(events.get(events.size() - 1).event == SimulationEvent.EventType.SimulationEnded,
				"Simulation didn't end with termination event");
			
			// Resources I'll need...
			List<SimulationEvent> pastEvents = new ArrayList<>();
			List<Integer> inProgressOrders = new ArrayList<>();
			List<Integer> completedOrders = new ArrayList<>();
			HashMap<Customer, Integer> currentOrders = new HashMap<>();
			HashMap<Customer, Integer> customerOrderCount = new HashMap<>();
			HashMap<Integer, List<Food>> orderFoodList = new HashMap<>();
			int expectedCustomers, expectedCooks, expectedTables, expectedMachineCount;
			int actualCustomers = 0, actualCooks = 0, currentCustomers = 0, startedMachines = 0;
			int[] requestedFood = {0, 0, 0, 0};												// [fries; pizzas; subs; sodas]
			int[] completedFood = {0, 0, 0, 0};												// [fries; pizzas; subs; sodas]
			int[] machinesQueue = {0, 0, 0, 0};												// [fries; pizzas; subs; sodas]
			
			// Determining expected values...
			String[] init = events.get(0).toString().split(" ");
			expectedCustomers = Integer.parseInt(init[2]);
			expectedCooks = Integer.parseInt(init[4]);
			expectedTables = Integer.parseInt(init[6]);
			expectedMachineCount = Integer.parseInt(init[12].replace(".", ""));
			
			for (SimulationEvent event : events) {
				count++;
				
				switch (event.event) {
					case CustomerStarting:
						actualCustomers++;
						break;
						
					/* Cases:
					 * 	1) There should never be more customers in Ratsie's than there are tables.
					 */
					case CustomerEnteredRatsies:
						currentCustomers++;
						check(currentCustomers <= expectedTables, 
								"Simulation had more customers in Ratsie's than was allowed.");
						break;
					
					/* Cases:
					 * 	1) Customer should not place more than one order.
					 */
					case CustomerPlacedOrder:
						check(!currentOrders.containsKey(event.customer) && !completedOrders.contains(event.orderNumber),
								"Customer has already placed an order.");
						check(!customerOrderCount.containsKey(event.customer),
								"Customer has already placed an order.");
						check(!orderFoodList.containsKey(event.orderNumber),
								"This order number is already in use.");
						currentOrders.put(event.customer, event.orderNumber);
						customerOrderCount.put(event.customer, 1);
						orderFoodList.put(event.orderNumber, event.orderFood);
						break;
					
					/* Cases:
					 * 	1) Customer should not receive an order before placing it.
					 *  2) Customer should receive an order with the same order number.
					 *  3) Customer should receive an order that contains everything they ordered.
					 *  4) Customer should not receive an order before it is completed.
					 */
					case CustomerReceivedOrder:
						check(currentOrders.containsKey(event.customer),
								"Customer received an order though they don't have one placed.");
						check(currentOrders.get(event.customer).equals(event.orderNumber),
								"Customer received an order that wasn't theirs.");
						int[] expectedCount = {0, 0, 0, 0};
						int[] actualCount = {0, 0, 0, 0};
						boolean equal = true;
						for (Food f : orderFoodList.get(event.orderNumber)) {
							switch (f.name) {
							case "fries": expectedCount[0]++;
								break;
							case "pizza": expectedCount[1]++;
								break;
							case "subs": expectedCount[2]++;
								break;
							case "soda": expectedCount[3]++;
								break;
							}
						}
						for (Food f : event.orderFood) {
							switch (f.name) {
							case "fries": actualCount[0]++;
								break;
							case "pizza": actualCount[1]++;
								break;
							case "subs": actualCount[2]++;
								break;
							case "soda": actualCount[3]++;
								break;
							}
						}
						for (int i = 0; i < 4; i++) {
							if (expectedCount[i] != actualCount[i]) {
								equal = false;
								break;
							}
						}
						check(equal,
								"Customer received an incorrect order.");
						check(completedOrders.contains(event.orderNumber),
								"Customer received their order even though it hasn't been completed yet.");
						currentOrders.remove(event.customer);
						break;
					
					/* Cases:
					 * 	1) Customer should not leave Ratsie's before receiving their order.
					 */
					case CustomerLeavingRatsies:
						check(!currentOrders.containsKey(event.customer),
								"Customer is leaving before receiving their order.");
						currentCustomers--;
						break;
					
					case CookStarting:
						actualCooks++;
						break;
					
					/* Cases:
					 * 	1) Cook should only receive an order after the customer has placed it.
					 * 	2) No more than one cook should receive the same order.
					 * 	3) Cook should not receive an order that has already been completed.
					 */
					case CookReceivedOrder:
						check(currentOrders.containsValue(event.orderNumber),
								"Cook received an order that hasn't been placed.");
						check(!inProgressOrders.contains(event.orderNumber),
								"Cook received an order that is already in progress.");
						check(!completedOrders.contains(event.orderNumber),
								"Cook received an order that has already been completed.");
						inProgressOrders.add(event.orderNumber);
						for (Food f : event.orderFood) {
							switch (f.name) {
							case "fries":
								requestedFood[0]++;
								break;
							case "pizza":
								requestedFood[1]++;
								break;
							case "subs":
								requestedFood[2]++;
								break;
							case "soda":
								requestedFood[3]++;
								break;
							default:
								System.err.println("Invalid food type.");
								break;
							}
						}
						break;
					
					/* Cases:
					 * 	1) This order should be active.
					 * 	2) Cook should not make food that isn't needed for the order.
					 * 	3) Cook should not start making food before receiving the order.
					 */
					case CookStartedFood:
						check(currentOrders.containsValue(event.orderNumber),
								"Cook started making food for an inactive order.");
						switch (event.food.name) {
						case "fries":
							check(requestedFood[0] > completedFood[0],
									"We don't need more of this type of food");
							break;
						case "pizza":
							check(requestedFood[1] > completedFood[1],
									"We don't need more of this type of food");
							break;
						case "subs":
							check(requestedFood[2] > completedFood[2],
									"We don't need more of this type of food");
							break;
						case "soda":
							check(requestedFood[3] > completedFood[3],
									"We don't need more of this type of food");
							break;
						default:
							System.err.println("Invalid food type.");
							break;
						}
						check(inProgressOrders.contains(event.orderNumber),
								"This order is not in progress yet.");
						break;
					
					/* Cases:
					 * 	1) This order should be active.
					 * 	2) Food should not be finished before the cook starts this food.
					 * 	3) Food should not be finished before the relevant machine finishes making it.
					 */
					case CookFinishedFood: // WIP
						check(currentOrders.containsValue(event.orderNumber),
								"This order is not active.");
						switch (event.food.name) {
						case "fries":
							completedFood[0]++;
							break;
						case "pizza":
							completedFood[1]++;
							break;
						case "subs":
							completedFood[2]++;
							break;
						case "soda":
							completedFood[3]++;
							break;
						default:
							System.err.println("Invalid food type.");
							break;
						}
						break;
					
					/* Cases:
					 * 	1) Cook should not complete this order until all the food for the order is ready.
					 * 	2) Cook should not complete this order before it is received.
					 */
					case CookCompletedOrder: // WIP
//						inProgressOrders.remove(event.orderNumber);
						completedOrders.add(event.orderNumber);
						break;
					
					/* Cases:
					 * 	1) Cook should not leave before s/he arrives.
					 * 	2) Cook should not leave while there are still customers waiting for their orders.
					 */
					case CookEnding:
						check(actualCustomers == expectedCustomers && currentCustomers == 0,
								"Cook left while there are still customers awaiting their orders.");
						break;
					
					/* Cases:
					 * 	1) The machine slots should match the expected value.
					 */
					case MachinesStarting:
						check(event.simParams[0] == expectedMachineCount,
								"Simulated machine did not start with the expected count.");
						startedMachines++;
						break;
					
					/* Cases:
					 * 	1) Machine should not start food if it is too busy processing other food.
					 * 	2) Machine should not start food if a cook has not requested it to do so.
					 */
					case MachinesStartingFood:
						switch (event.food.name) {
						case "fries":
							check(requestedFood[0] > completedFood[0],
									"There is no active request for this type of food.");
							check(machinesQueue[0] <= expectedMachineCount,
									"The fryer started more food than it could handle. (" + machinesQueue[0] + ")");
							machinesQueue[0]++;
							break;
						case "pizza":
							check(requestedFood[1] > completedFood[1],
									"There is no active request for this type of food.");
							check(machinesQueue[1] <= expectedMachineCount,
									"The oven started more food than it could handle. (" + machinesQueue[1] + ")");
							machinesQueue[1]++;
							break;
						case "subs":
							check(requestedFood[2] > completedFood[2],
									"There is no active request for this type of food.");
							check(machinesQueue[2] <= expectedMachineCount,
									"The grill started more food than it could handle. (" + machinesQueue[2] + ")");
							machinesQueue[2]++;
							break;
						case "soda":
							check(requestedFood[3] > completedFood[3],
									"There is no active request for this type of food.");
							check(machinesQueue[3] <= expectedMachineCount,
									"The soda fountain started more food than it could handle. (" + machinesQueue[3] + ")");
							machinesQueue[3]++;
							break;
						default:
							System.err.println("Invalid food type.");
							break;
						}
						break;
					
					/* Cases:
					 * 	1) Machine should not finish food it hasn't started.
					 */
					case MachinesDoneFood:
						switch (event.food.name) {
						case "fries":
							check(machinesQueue[0] > 0,
									"The fryer finished food when there was none to make.");
							machinesQueue[0]--;
							break;
						case "pizza":
							check(machinesQueue[1] > 0,
									"The oven finished food when there was none to make.");
							machinesQueue[1]--;
							break;
						case "subs":
							check(machinesQueue[2] > 0,
									"The grill finished food when there was none to make.");
							machinesQueue[2]--;
							break;
						case "soda":
							check(machinesQueue[3] > 0,
									"The soda fountain finished food when there was none to make.");
							machinesQueue[3]--;
							break;
						default:
							System.err.println("Invalid food type.");
							break;
						}
						break;
					
					/* Cases:
					 * 	1) Machines should not end before starting.
					 * 	2) Machines should not end before they are done processing all food.
					 */
					case MachinesEnding:
						check(startedMachines == 4, "Not all four machines started.");
						for (int i = 0; i < 4; i++) {
							check(machinesQueue[i] == 0,
									"One of the machines still has requested food.");
							check(requestedFood[i] == completedFood[i],
									"One of the machines still has requested food.");
						}
						break;

					default: break;
				}
				
				pastEvents.add(event);
			}
			
			check(expectedCustomers == actualCustomers,
					"Simulation didn't have the expected number of customers. Expected " + expectedCustomers + " but got " + actualCustomers);
			check(expectedCooks == actualCooks,
					"Simulation didn't have the expected number of cooks. Expected " + expectedCooks + " but got " + actualCooks);
			check(currentCustomers == 0,
					"There are still customers in Ratsie's.");
			check(currentOrders.isEmpty(),
					"There are still active orders.");

			/*
			 * In P2 you will write validation code for things such as:
			 * Should not have more eaters than specified
			 * Should not have more cooks than specified
			 * The Ratsie's capacity should not be exceeded
			 * The capacity of each machine should not be exceeded
			 * Eater should not receive order until cook completes it
			 * Eater should not leave Ratsie's until order is received
			 * Eater should not place more than one order
			 * Cook should not work on order before it is placed
			 */

			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}

	}
}
